"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.upload=void 0;const path=require("path"),fs=require("fs"),request_1=require("../utils/request"),compile_1=require("../compile"),pack_1=require("../pack/pack"),zlib=require("zlib"),sign_1=require("../utils/sign"),tools_1=require("../utils/tools"),config_1=require("../config"),taskstatus_1=require("../utils/taskstatus"),log=require("../utils/log"),CodeError=require("../utils/error"),locales=require("../utils/locales/locales"),QueryString=require("querystring"),url_config_1=require("../utils/url_config"),terminalQrcode_1=require("../utils/terminalQrcode"),jsonParse_1=require("../utils/jsonParse"),SIGNATURE_FILE_NAME="ci.signature";async function upload(e){const{project:r,setting:o={},desc:t=`robot ${e.robot||"1"} use miniprogram-ci to upload at ${tools_1.formatTime(new Date)}`,version:i="",robot:s="1",onProgressUpdate:n=function(e){console.log(""+e)},test:a,pagePath:c,searchQuery:l}=e;if(!i)throw new CodeError(locales.config.PARAM_ERROR.format("upload","version"),config_1.PARAM_ERROR);if(!r)throw new CodeError(locales.config.PARAM_ERROR.format("upload","project"),config_1.PARAM_ERROR);let u=await compile_1.compile(r,{setting:o,onProgressUpdate:n});const d=await sign_1.getSignature(r.privateKey,r.appid);let p="1.0.0";try{p=JSON.parse(fs.readFileSync(path.posix.join(__dirname,"../../package.json"),"utf8")).version}catch(e){p="unknow"}u["ci.signature"]=JSON.stringify({signature:d,version:p});const g=pack_1.pack(u),f=zlib.gzipSync(g.buffer),_={codeprotect:o.codeProtect?1:0,type:r.type,appid:r.appid,version:i,desc:t,robot:s},y={scene:e.scene||1011};let q;c&&(y.path=c,_.path=c),l&&(y.query=QueryString.parse(l)),_.debugLaunchInfo=JSON.stringify(y),c&&l&&(_.path+="?"+l);let m={};try{q=await r.getFile(r.miniprogramRoot,"ext.json"),m=JSON.parse(q.toString("utf-8"))}catch(e){}if(m&&(m.extEnable&&(_.extAppId=m.extAppid),m.directCommit)){let e="";e=m.extEnable?"The code will be uploaded into the draft box of the third-party platform.":"The code will be uploaded into the waiting list of extAppid.",log.warn(e)}try{const r=new taskstatus_1.TaskStatus(locales.config.UPLOAD);n(r);const o=`${a?url_config_1.TEST_SOURCE_URL:url_config_1.UPLOAD_URL}?${QueryString.stringify(_)}`;log.info("request url:",o);const t=(await request_1.request({url:o,method:"post",body:f})).body.toString();r.done(),n(r);const i=jsonParse_1.jsonRespParse(t,o);if(0===i.errCode){const r={};if(Array.isArray(i.body.subpackage_info)){const e=i.body.subpackage_info;r.subPackageInfo=e}if(Array.isArray(i.body.ext_plugin_info)){const e=i.body.ext_plugin_info;r.pluginInfo=e.map(e=>({pluginProviderAppid:e.provider,version:e.version,size:e.size}))}if(e.test){if(!i.body.qrcode_img)throw new Error("No `qrcode_img` in response.");if("terminal"===e.qrcodeFormat)try{const e=await terminalQrcode_1.generateTerminalQrcode(i.body.qrcode_img);log.log(e),log.log("terminal qrcode shown above")}catch(e){log.error("Termianl qrcode generate failed, but you can still visit the dev version on your cell phone.")}else if(e.qrcodeOutputDest)if("image"===e.qrcodeFormat)try{fs.writeFileSync(e.qrcodeOutputDest,Buffer.from(i.body.qrcode_img,"base64")),log.info(`Qrcode image saved, file path: '${e.qrcodeOutputDest}'`)}catch(e){throw new Error("write qrcode image error: "+JSON.stringify(e))}else if("base64"===e.qrcodeFormat)try{fs.writeFileSync(e.qrcodeOutputDest,"data:image/jpeg;base64,"+i.body.qrcode_img,"utf8"),log.info(`Qrcode base64 file saved, file path: '${e.qrcodeOutputDest}'`)}catch(e){throw new Error("write qrcode base64 error: "+JSON.stringify(e))}}if(!e.test&&i.body&&i.body.dev_plugin_id){const{dev_plugin_id:e}=i.body;log.log("Development Version Plugin ID: "+e),r.devPluginId=e}return r}throw new Error(t)}catch(e){throw new CodeError(e.toString(),config_1.UPLOAD_CGI_ERR)}}exports.upload=upload;